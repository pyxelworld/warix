<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title>Futebol de Arena</title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.6">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px;
text-align: center; font: 24.0px Helvetica; color: #343736; -webkit-text-stroke: #343736; min-height: 29.0px}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #164fc7; -webkit-text-stroke: #164fc7; background-color: #ecf1f7}
    p.p3 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #18702b; -webkit-text-stroke: #18702b; background-color: #ecf1f7}
    p.p4 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #cd1a1d; -webkit-text-stroke: #cd1a1d; background-color: #ecf1f7}
    p.p5 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #45494c; -webkit-text-stroke: #45494c; background-color: #ecf1f7}
    p.p6 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #4d5055; -webkit-text-stroke: #4d5055; background-color: #ecf1f7}
    p.p7 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #45494c; -webkit-text-stroke: #45494c; background-color: #ecf1f7; min-height: 17.0px}
    p.p8 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #6f0ec3; -webkit-text-stroke: #6f0ec3; background-color: #ecf1f7}
    p.p9 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #a4450b; -webkit-text-stroke: #a4450b; background-color: #ecf1f7}
    p.p10 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #865603; -webkit-text-stroke: #865603; background-color: #ecf1f7}
    p.p11 {margin: 0.0px 0.0px 0.0px 0.0px;
font: 14.0px Helvetica; color: #151516; -webkit-text-stroke: #151516; background-color: #ecf1f7}
    span.s1 {font-kerning: none}
    span.s2 {font-kerning: none;
color: #45494c; -webkit-text-stroke: 0px #45494c}
    span.s3 {font-kerning: none; color: #cd1a1d;
-webkit-text-stroke: 0px #cd1a1d}
    span.s4 {font-kerning: none; color: #a4450b; -webkit-text-stroke: 0px #a4450b}
    span.s5 {font-kerning: none;
color: #18702b; -webkit-text-stroke: 0px #18702b}
    span.s6 {font-kerning: none; color: #6f0ec3;
-webkit-text-stroke: 0px #6f0ec3}
    span.s7 {font-kerning: none; color: #164fc7; -webkit-text-stroke: 0px #164fc7}
    span.s8 {font-kerning: none;
color: #865603; -webkit-text-stroke: 0px #865603}
    span.s9 {font-kerning: none; color: #151516;
-webkit-text-stroke: 0px #151516}
    span.s10 {font-kerning: none; color: #4d5055;
-webkit-text-stroke: 0px #4d5055}

    :root {
        /* Cores primárias mais vivas e claras */
        --realistic-blue-dark: #3E6694; /* Azul escuro mais brilhante */ 
        --realistic-blue-light: #678BB1; /* Azul claro mais brilhante */ 
        --field-color-dark: #38A757; /* Verde escuro do campo mais vívido */ 
        --field-color-light: #48C268; /* Verde claro do campo mais vívido */ 
        --line-color: rgba(255, 255, 255, 1.0); /* Linhas brancas sólidas */ 
        --text-color: #F5F7FA; /* Texto branco mais claro */ 
        --accent-color-1: #4D8BFF; /* Azul de destaque mais brilhante */ 
        --accent-color-2: #FF5F5F; /* Vermelho de destaque mais brilhante */ 
        --button-primary-bg: #3DCC61; /* Botão primário verde vívido */ 
        --button-primary-hover: #33A851;/* Hover do botão primário */
        --button-secondary-bg: var(--accent-color-1); /* Botão secundário usa o novo azul */ 
        --button-secondary-hover: #3A7BEE; /* Hover do botão secundário */ 
        --warning-color: #FFD32A; /* Cor de aviso amarela mais vívida */ 
        --shadow-color: rgba(0, 0, 0, 0.55); /* Sombra um pouco mais suave */ 
        --overlay-bg: rgba(20, 35, 60, 0.93); /* Overlay de fundo levemente mais claro */ 
        --border-radius-main: 20px;
        --border-radius-small: 10px;
        --goal-post-color: #F0F0F0;     /* Traves mais claras */ 
    }

    * {
        box-sizing: border-box;
        margin: 0; 
        padding: 0;
    }

    body {
        display: flex; /* Mantém flex para o layout principal */
        flex-direction: column; /* Empilha o game wrapper e outros elementos globais futuros */
        height: 100vh;
        background: linear-gradient(145deg, var(--realistic-blue-dark) 0%, var(--realistic-blue-light) 100%); /* Este será o fundo principal */
        font-family: 'Roboto', sans-serif;
        color: var(--text-color);
        overflow: hidden;
        user-select: none; 
    }

    #gameWrapper {
        position: relative;
        width: 100%;
        flex-grow: 1; /* Ocupa o espaço vertical disponível */
        background: transparent; /* O fundo original do body será exibido */
        display: flex;
        flex-direction: column; /* Para empilhar gameContainer e footerControls */
        overflow: hidden; /* Impede que o conteúdo cause barras de rolagem no body */
    }

    #gameWrapper.shake {
        animation: screenShake 0.35s cubic-bezier(.36,.07,.19,.97) both; /* Animação de shake mais rápida */ 
    }

    @keyframes screenShake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 50%, 70% { transform: translate3d(-3px, 0, 0); }
        40%, 60% { transform: translate3d(3px, 0, 0); }
    }

    #gameContainer {
        flex-grow: 1; /* Ocupa espaço acima do rodapé */
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden; /* Importante para canvas object-fit */
    }

    canvas {
        border: 2px solid rgba(255, 255, 255, 0.75); /* Borda do canvas mais forte */ 
        border-radius: 12px; /* Raio da borda ajustado */ 
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.45) inset, 0 8px 20px rgba(0, 0, 0, 0.35); /* Sombra ajustada */ 
        display: block;
        background-color: var(--field-color-dark); /* Cor de fundo do campo */ 
        transition: filter 0.25s ease;
        max-width: 100%; /* Escala com o pai */
        max-height: 100%; /* Escala com o pai */
        object-fit: contain; /* Mantém a proporção */
    }

    canvas.paused-visual { filter: blur(2.5px) brightness(0.65); } /* Efeito de pausa mais sutil */

    #uiContainer {
        display: flex;
        justify-content: space-between; 
        align-items: center;
        /* margin-top será tratado pelo footerControls */
        padding: 0 10px; /* Mantém o padding horizontal */
        font-family: 'Orbitron', sans-serif; /* Mantém a fonte */
        width: 100%; /* Ocupa a largura total do footerControls */
        max-width: 840px; /* Opcional: restringe a largura em telas muito grandes, corresponde à largura do canvas + padding */
    }

    #scoreBoard, #timer {
        font-size: 26px; /* Tamanho da fonte ajustado */ 
        font-weight: 700;
        text-shadow: 2px 2px 5px var(--shadow-color); 
        background: rgba(0, 0, 0, 0.4);
        padding: 12px 24px; /* Padding ajustado */
        border-radius: var(--border-radius-small); 
        border: 1px solid rgba(255, 255, 255, 0.25);
        min-width: 160px; /* Largura mínima ajustada */
        text-align: center;
        transition: all 0.25s ease; 
    }

    #timer { color: var(--warning-color); font-weight: 900; }
    #scoreBoard:hover, #timer:hover {
        transform: scale(1.02); /* Efeito de hover sutil */ 
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.2); }

    #controlsInfo {
        /* margin-top será tratado pelo footerControls ou margem direta */ 
        font-size: 14px; /* Tamanho da fonte ajustado */ 
        color: #c0c8cf; /* Cor do texto de controles */ 
        background: rgba(0, 0, 0, 0.2); 
        padding: 12px;
        border-radius: var(--border-radius-small);
        min-height: 44px;
        text-align: center;
        font-style: italic;
        border: 1px solid rgba(255, 255, 255, 0.1); 
        margin-top: 8px; /* Espaço do placar/timer se na mesma coluna flex */
    }

    /* Novo Estilo do Rodapé */
    #footerControls {
        width: 100%;
        padding: 10px 0; /* Padding vertical, horizontal tratado pelos filhos ou pode ser adicionado aqui */
        background: rgba(10, 20, 35, 0.75); /* Rodapé mais escuro e levemente transparente */
        box-shadow: 0 -4px 12px rgba(0,0,0,0.3); /* Sombra na borda superior */
        z-index: 50;
        display: flex;
        flex-direction: column;
        align-items: center; /* Centraliza #uiContainer e #controlsInfo se não ocuparem largura total */
    }

    .button {
        padding: 14px 32px; /* Padding do botão ajustado */ 
        font-size: 17px; /* Tamanho da fonte do botão ajustado */ 
        color: white;
        border: none;
        border-radius: 25px; /* Raio da borda do botão ajustado */ 
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); 
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px; /* Espaçamento entre letras ajustado */ 
        background: var(--button-primary-bg); 
        border-bottom: 4px solid rgba(0, 0, 0, 0.3);
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3); 
    }
    .button:hover {
        transform: translateY(-5px) scale(1.03); /* Efeito de hover ajustado */ 
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.3); 
        background: var(--button-primary-hover);
        filter: brightness(1.1);
    }
    .button:active {
        transform: translateY(0px) scale(0.97); /* Efeito de clique ajustado */ 
        box-shadow: 0 3px 7px rgba(0, 0, 0, 0.25); 
        border-bottom-width: 2px;
    }

    .button.secondary { background: var(--button-secondary-bg); border-bottom-color: #3A7BEEe0; } /* Cor da borda inferior ajustada */
    .button.secondary:hover { background: var(--button-secondary-hover); }
    .button.warning { background: var(--warning-color); color: #282828; border-bottom-color: #d8a106cc; font-weight: 900;}
    .button.warning:hover { background: #ffcf40; }

    .screen {
        position: absolute; 
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        background: var(--overlay-bg);
        z-index: 100;
        transition: opacity 0.4s ease, visibility 0.4s ease; /* Transição mais rápida */ 
        border-radius: var(--border-radius-main); 
        opacity: 1; visibility: visible;
        padding: 25px; /* Padding ajustado */
        backdrop-filter: blur(6px); /* Blur ajustado */ 
        text-align: center; 
    }
    .screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

    .screen h1, .screen h2 {
        font-family: 'Orbitron', sans-serif; 
        margin-bottom: 25px; /* Margem ajustada */
        text-shadow: 4px 4px 8px var(--shadow-color);
        color: var(--text-color); 
    }
    .screen h1 { font-size: 56px; color: var(--warning-color); font-weight: 900;} /* Tamanho ajustado */
    .screen h2 { font-size: 44px; color: var(--text-color); } /* Tamanho ajustado, MODIFICADO: cor alterada para var(--text-color) */
    #endScreen #endTitle { font-size: 60px; } /* Tamanho ajustado */

    .screen p {
        font-size: 21px; /* Tamanho da fonte ajustado */ 
        margin-bottom: 40px; /* Margem ajustada */ 
        color: #e0e6eb; /* Cor do parágrafo ajustada */ 
        max-width: 85%;
        line-height: 1.4; 
    }
    #endScreen #finalScore { font-size: 28px; font-weight: bold; } /* Tamanho ajustado */
    .screen .button { margin: 15px; } /* Margem do botão ajustada */

    .settings-button {
        position: absolute;
        top: 25px; right: 25px; /* Posição ajustada */ 
        width: 54px; height: 54px; /* Tamanho ajustado */ 
        background: rgba(255, 255, 255, 0.2); /* Fundo ajustado */ 
        border: 1px solid rgba(255, 255, 255, 0.28);
        border-radius: 50%; 
        cursor: pointer; z-index: 101;
        transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        display: flex; justify-content: center; align-items: center; 
        box-shadow: 0 4px 10px rgba(0,0,0,0.35);
        font-size: 30px; /* Tamanho do ícone ajustado */
        line-height: 1; 
        color: var(--text-color);
    }
    .settings-button:hover {
        background: rgba(255, 255, 255, 0.3); 
        transform: rotate(120deg) scale(1.1); /* Rotação e escala ajustadas */
        box-shadow: 0 6px 15px rgba(0,0,0,0.45); 
    }

    .settings-group {
        background: rgba(255, 255, 255, 0.08); /* Fundo ajustado */ 
        padding: 30px; /* Padding ajustado */ 
        border-radius: var(--border-radius-main);
        margin-bottom: 30px;
        width: 90%; max-width: 500px; /* Largura máxima ajustada */ 
        text-align: center; 
        border: 1px solid rgba(255, 255, 255, 0.15);
        box-shadow: 0 5px 15px rgba(0,0,0,0.25);
        transition: all 0.25s ease; 
    }
    .settings-group:hover {
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        transform: translateY(-2px); 
    }

    .settings-group h3 {
        margin-top: 0; margin-bottom: 25px; /* Margem ajustada */ 
        color: var(--warning-color);
        font-family: 'Orbitron', sans-serif;
        font-size: 22px; /* Tamanho da fonte ajustado */ 
        text-shadow: 1px 1px 3px rgba(0,0,0,0.45); 
    }
    .settings-group .button {
        font-size: 15px; /* Tamanho da fonte ajustado */ 
        padding: 13px 25px; /* Padding ajustado */ 
        margin: 8px; /* Margem ajustada */ 
    }
    .settings-group .button.active {
        background: var(--button-primary-bg); 
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3) inset;
        transform: translateY(1px);
        filter: brightness(0.9); 
    }
    .settings-group .button:not(.active) {
        background: #555e68; /* Cor de fundo ajustada */ 
        border-bottom-color: #3c4248; 
    }
    .settings-group .button:not(.active):hover {
        background: #656e78; /* Cor de fundo ajustada */ 
        transform: translateY(-2px) scale(1.01); 
    }

    .color-picker {
        display: flex; justify-content: center;
        gap: 20px; /* Espaçamento ajustado */ 
        margin-bottom: 20px;
        flex-wrap: wrap; 
    }
    .color-box {
        width: 44px; height: 44px; /* Tamanho ajustado */ 
        border-radius: 50%; cursor: pointer;
        border: 5px solid transparent; /* Borda ajustada */ 
        transition: transform 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease; 
        box-shadow: 0 3px 7px rgba(0,0,0,0.4);
    }
    .color-box:hover {
        transform: scale(1.15); /* Efeito de hover ajustado */ 
        box-shadow: 0 5px 12px rgba(0,0,0,0.5); 
    }
    .color-box.selected {
        border-color: var(--text-color);
        transform: scale(1.2); /* Efeito de seleção ajustado */ 
        box-shadow: 0 0 18px rgba(255, 255, 255, 0.7); 
    }

    #backButton { background: #656e78; border-bottom-color: #454c52; } /* Cores ajustadas */
    #backButton:hover { background: #555c64; } /* Cores ajustadas */
  </style>
</head>
<body>

<div id="gameWrapper">
    <button id="settingsButton" class="settings-button" title="Configurações"><i class="fas fa-cog"></i></button>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="450"></canvas>
    </div>

    <div id="footerControls">
        <div id="uiContainer">
            <div id="scoreBoard">Jogador 1: 0 | CPU: 0</div> 
            <div id="timer">Tempo: 2:00</div>
        </div>
        <div id="controlsInfo">Use WASD ou Setas para mover.</div>
    </div>

    <div id="startScreen" class="screen">
        <h1>FUTEBOL DE ARENA</h1>
        <p>Domine o campo e marque gols incríveis!</p>
        <button id="startButton" class="button">Iniciar Jogo</button>
        <button id="openSettingsButton" class="button secondary">Configurações</button>
    </div>

    <div id="endScreen" class="screen hidden">
        <h1 id="endTitle">Você Venceu!</h1>
        <p id="finalScore">Placar final: Jogador 5 - 3 Oponente</p> 
        <button id="playAgainButton" class="button">Jogar Novamente</button>
    </div>

    <div id="settingsScreen" class="screen hidden">
        <h2>Configurações</h2>
        <div class="settings-group">
            <h3>Modo de Jogo</h3>
            <button id="singlePlayerButton" class="button">1 Jogador</button>
            <button id="multiPlayerButton" class="button">2 Jogadores</button>
        </div>
        <div class="settings-group" id="controlModeGroup"> 
            <h3>Controle (1 Jogador)</h3>
            <button id="keyboardButton" class="button">Teclado</button>
            <button id="mouseButton" class="button">Mouse/Touch</button>
        </div>
        <div class="settings-group">
            <h3>Aparência</h3>
            <button id="customizeButton" class="button secondary">Personalizar Jogadores</button>
        </div>
        <button id="closeSettingsButton" class="button warning">Salvar e Fechar</button> 
    </div>

    <div id="customizationScreen" class="screen hidden">
        <h2>Personalizar Jogadores</h2>
        <div class="settings-group">
            <h3>Cor do Jogador 1</h3>
            <div id="player1ColorPicker" class="color-picker"></div>
        </div>
        <div class="settings-group">
            <h3>Cor do Jogador 2 / Oponente</h3>
            <div id="player2ColorPicker" class="color-picker"></div> 
        </div>
        <button id="backButton" class="button">Voltar</button>
    </div>
</div>

<script>
    const gameWrapper = document.getElementById('gameWrapper'); 
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreBoard = document.getElementById('scoreBoard');
    const timerDisplay = document.getElementById('timer');
    const startScreen = document.getElementById('startScreen'); 
    const endScreen = document.getElementById('endScreen');
    const settingsScreen = document.getElementById('settingsScreen');
    const customizationScreen = document.getElementById('customizationScreen');
    const endTitle = document.getElementById('endTitle');
    const finalScoreDisplay = document.getElementById('finalScore'); 
    const startButton = document.getElementById('startButton');
    const openSettingsButton = document.getElementById('openSettingsButton');
    const playAgainButton = document.getElementById('playAgainButton');
    const settingsButton = document.getElementById('settingsButton');
    const closeSettingsButton = document.getElementById('closeSettingsButton'); 
    const customizeButton = document.getElementById('customizeButton');
    const backButton = document.getElementById('backButton');
    const singlePlayerButton = document.getElementById('singlePlayerButton');
    const multiPlayerButton = document.getElementById('multiPlayerButton');
    const keyboardButton = document.getElementById('keyboardButton'); 
    const mouseButton = document.getElementById('mouseButton');
    const controlModeGroup = document.getElementById('controlModeGroup');
    const controlsInfo = document.getElementById('controlsInfo');
    const player1ColorPicker = document.getElementById('player1ColorPicker');
    const player2ColorPicker = document.getElementById('player2ColorPicker'); 

    const fieldWidth = canvas.width;
    const fieldHeight = canvas.height;
    const playerRadius = 18;
    const ballRadius = 9;
    const goalWidth = 10; 
    const goalLineY1 = fieldHeight / 2 - 65;
    const goalLineY2 = fieldHeight / 2 + 65; 
    const goalHeight = goalLineY2 - goalLineY1;
    const goalPostRadius = 7;

    let fieldColorLightCSS, fieldColorDarkCSS, lineColorCSS, goalPostColorCSSValue;
    const goalPosts = [ 
        { x: goalPostRadius, y: goalLineY1, radius: goalPostRadius, side: 'left' },
        { x: goalPostRadius, y: goalLineY2, radius: goalPostRadius, side: 'left' },
        { x: fieldWidth - goalPostRadius, y: goalLineY1, radius: goalPostRadius, side: 'right' },
        { x: fieldWidth - goalPostRadius, y: goalLineY2, radius: goalPostRadius, side: 'right' }
    ];
    let player1 = { x: 150, y: fieldHeight / 2, score: 0, speed: 5.8, color: '#4285f4' }; 
    let player2 = { x: fieldWidth - 150, y: fieldHeight / 2, score: 0, speed: 5.8, color: '#ea4335' }; // Player 2 (CPU or Human)
    let opponent = { speed: 4.9 }; // For CPU specific settings 

    let ball = { x: fieldWidth / 2, y: fieldHeight / 2, vx: 0, vy: 0, speed: 8.0, maxSpeed: 14.5, friction: 0.996, kickStrength: 1.75 }; 

    let gameTime = 120, gameInterval, isGameRunning = false, isPausedForMenu = false, goalPauseActive = false, goalPauseTimer = 0; 
    const GOAL_PAUSE_DURATION = 110, KICKOFF_DELAY = 1100;
    let keys = {}, animationFrameId, lastScorer = null; 
    let settings = { gameMode: 'single', controlMode: 'keyboard', player1Color: '#4D8BFF', player2Color: '#FF5F5F' }; 
    const availableColors = ['#4D8BFF', '#FF5F5F', '#3DCC61', '#FFD32A', '#9b59b6', '#1abc9c', '#F0F0F0', '#34495e', '#e67e22', '#5dade2']; 

    // AI State Variables
    let cpuCanMove = true; 
    let cpuLastStrategicUpdateTime = 0; 
    let cpuStrategicTargetX = fieldWidth - 150; 
    let cpuStrategicTargetY = fieldHeight / 2; 
    const AI_STRATEGIC_UPDATE_INTERVAL_MS = 120; // How often CPU updates its main strategy (in milliseconds) (Reduced for faster reaction)

    function saveSettings() { localStorage.setItem('arenaSoccerSettingsV8', JSON.stringify(settings)); }
    function loadSettings() {
        const saved = localStorage.getItem('arenaSoccerSettingsV8'); 
        if (saved) settings = JSON.parse(saved);
        player1.color = settings.player1Color;
        player2.color = settings.player2Color;

        const rootStyle = getComputedStyle(document.documentElement);
        fieldColorLightCSS = rootStyle.getPropertyValue('--field-color-light').trim(); 
        fieldColorDarkCSS = rootStyle.getPropertyValue('--field-color-dark').trim(); 
        lineColorCSS = rootStyle.getPropertyValue('--line-color').trim(); 
        goalPostColorCSSValue = rootStyle.getPropertyValue('--goal-post-color').trim(); 

        updateSettingsUI(); 
    }

    function updateSettingsUI() {
        singlePlayerButton.classList.toggle('active', settings.gameMode === 'single'); 
        multiPlayerButton.classList.toggle('active', settings.gameMode === 'multiplayer'); 
        controlModeGroup.style.display = settings.gameMode === 'single' ? 'block' : 'none'; 
        keyboardButton.classList.toggle('active', settings.controlMode === 'keyboard'); 
        mouseButton.classList.toggle('active', settings.controlMode === 'mouse'); 
        updateControlsInfo();
        updateColorPickerUI(player1ColorPicker, settings.player1Color);
        updateColorPickerUI(player2ColorPicker, settings.player2Color);
    }

    function updateControlsInfo() {
        if (settings.gameMode === 'single') {
            scoreBoard.textContent = `Jogador: ${player1.score} | CPU: ${player2.score}`; 
            controlsInfo.textContent = settings.controlMode === 'mouse' ? "Use Mouse/Touch para mover." : "Use WASD ou Setas para mover."; 
        } else {
            scoreBoard.textContent = `P1: ${player1.score} | P2: ${player2.score}`; 
            controlsInfo.textContent = "P1: WASD | P2: Setas."; 
        }
    }

    function createColorPicker(pickerElement, settingKey) {
        pickerElement.innerHTML = ''; 
        availableColors.forEach(color => { 
            const box = document.createElement('div');
            box.classList.add('color-box'); box.style.backgroundColor = color; box.dataset.color = color;
            box.addEventListener('click', () => {
                settings[settingKey] = color;
                if(settingKey === 'player1Color') player1.color = color; else player2.color = color;
                updateColorPickerUI(pickerElement, color); saveSettings(); drawEverything(); 
            });
            pickerElement.appendChild(box); 
        });
    }
    function updateColorPickerUI(pickerElement, selectedColor) { pickerElement.querySelectorAll('.color-box').forEach(box => box.classList.toggle('selected', box.dataset.color === selectedColor)); }

    function showScreen(screenElement) {
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        screenElement.classList.remove('hidden'); 
        isPausedForMenu = true; canvas.classList.add('paused-visual'); 
        if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
    }
    function hideScreen(screenElement) { screenElement.classList.add('hidden'); } 

    function openSettingsMenu() { showScreen(settingsScreen); updateSettingsUI(); }
    function closeSettingsMenu() {
        hideScreen(settingsScreen); hideScreen(customizationScreen); 
        isPausedForMenu = false; 
        canvas.classList.remove('paused-visual'); 
        if (isGameRunning && !goalPauseActive) {
            resumeGameLogic(); 
        } else if (!isGameRunning && endScreen.classList.contains('hidden')) {
            showScreen(startScreen); 
        }
        saveSettings(); updateControlsInfo(); 
    }

    function drawField() {
        const stripeWidth = 50; 
        for (let i = 0; i < fieldWidth / stripeWidth; i++) { 
            ctx.fillStyle = i % 2 === 0 ? fieldColorLightCSS : fieldColorDarkCSS; 
            ctx.fillRect(i * stripeWidth, 0, stripeWidth, fieldHeight); 
        }

        ctx.save(); 
        ctx.strokeStyle = `rgba(220, 235, 255, 0.85)`;  
        ctx.shadowColor = 'white'; 
        ctx.shadowBlur = 22;  
        ctx.lineWidth = 4; 
        ctx.strokeRect(0, 0, fieldWidth, fieldHeight); 
        ctx.restore(); 
        ctx.strokeStyle = lineColorCSS; 
        ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(fieldWidth / 2, 0); ctx.lineTo(fieldWidth / 2, fieldHeight); 
        ctx.stroke(); 
        ctx.beginPath(); 
        ctx.arc(fieldWidth / 2, fieldHeight / 2, 70, 0, Math.PI * 2); ctx.stroke(); 
        ctx.beginPath(); 
        ctx.arc(fieldWidth / 2, fieldHeight / 2, 5, 0, Math.PI * 2); 
        ctx.fillStyle = lineColorCSS; ctx.fill(); 
        ctx.lineWidth = 2; 
        ctx.strokeRect(0, fieldHeight / 2 - 100, 130, 200); 
        ctx.strokeRect(fieldWidth - 130, fieldHeight / 2 - 100, 130, 200); 
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)'; ctx.lineWidth = 1.5; 
        for (let i = 0; i < goalHeight; i += 10) {  
            ctx.beginPath(); 
            ctx.moveTo(0, goalLineY1 + i); ctx.lineTo(goalWidth, goalLineY1 + i); ctx.stroke();  
            if (i % 20 === 0) {  
                 ctx.beginPath(); 
                 ctx.moveTo(goalWidth/2, goalLineY1); ctx.lineTo(goalWidth/2, goalLineY2); ctx.stroke(); 
            }
            ctx.beginPath(); 
            ctx.moveTo(fieldWidth, goalLineY1 + i); ctx.lineTo(fieldWidth - goalWidth, goalLineY1 + i); ctx.stroke(); 
            if (i % 20 === 0) {  
                 ctx.beginPath(); 
                 ctx.moveTo(fieldWidth - goalWidth/2, goalLineY1); ctx.lineTo(fieldWidth - goalWidth/2, goalLineY2); ctx.stroke(); 
            }
        }
         for (let j = 0; j <= goalWidth; j += 10) {  
            ctx.beginPath(); 
            ctx.moveTo(j, goalLineY1); ctx.lineTo(j, goalLineY2); ctx.stroke(); 
            ctx.beginPath(); ctx.moveTo(fieldWidth - j, goalLineY1); ctx.lineTo(fieldWidth - j, goalLineY2); ctx.stroke(); 
        }

        ctx.fillStyle = goalPostColorCSSValue; 
        goalPosts.forEach(post => { 
            ctx.beginPath(); ctx.arc(post.x, post.y, post.radius, 0, Math.PI * 2); ctx.fill(); 
            ctx.beginPath(); ctx.arc(post.x, post.y, post.radius * 0.6, 0, Math.PI * 2); 
            ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill(); 
            ctx.fillStyle = goalPostColorCSSValue; 
        });
    }

    function drawPlayer(p) {
        ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.3)'; 
        ctx.shadowBlur = 9; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 4; 
        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, playerRadius, 0, Math.PI * 2); 
        ctx.fill(); 
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 2; ctx.stroke(); 
        ctx.restore(); 

        ctx.beginPath(); 
        ctx.arc(p.x - 5, p.y - 5, 5, 0, Math.PI * 2); 
        ctx.fillStyle = 'rgba(255, 255, 255, 0.35)'; ctx.fill(); 
    }

    function drawBall() {
        ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.3)'; 
        ctx.shadowBlur = 7; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 3; 
        ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2); 
        ctx.fill(); 
        ctx.restore(); 
        ctx.strokeStyle = 'black'; ctx.lineWidth = 1.2; 
        for(let i = 0; i < 3; i++) { 
            ctx.beginPath(); 
            ctx.arc(ball.x, ball.y, ballRadius, Math.PI * (i * 0.66), Math.PI * (i * 0.66 + 0.33), false); ctx.stroke(); 
        }
    }
    function drawGoalMessage() {
        if (!goalPauseActive) return; 
        const alpha = Math.min(1, (GOAL_PAUSE_DURATION - goalPauseTimer) / (GOAL_PAUSE_DURATION / 2)); 
        ctx.save(); 
        ctx.fillStyle = `rgba(0, 0, 0, ${0.55 * alpha})`; 
        ctx.fillRect(0, fieldHeight / 3, fieldWidth, fieldHeight / 3); 
        ctx.font = `bold ${55 + 10 * alpha}px Orbitron`; 
        ctx.fillStyle = `rgba(255, 223, 0, ${alpha})`; 
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'black'; ctx.shadowBlur = 8; 
        ctx.fillText('GOOOAL!', fieldWidth / 2, fieldHeight / 2); 
        ctx.restore(); 
    }
    function drawEverything() {
        ctx.clearRect(0, 0, fieldWidth, fieldHeight); 
        drawField(); drawPlayer(player1); drawPlayer(player2); drawBall(); drawGoalMessage(); 
    }

    function updateScoreDisplay() {
        scoreBoard.textContent = settings.gameMode === 'single' ? 
            `Jogador: ${player1.score} | CPU: ${player2.score}` : `P1: ${player1.score} | P2: ${player2.score}`; 
    }
    function updateTimerDisplay() {
        let minutes = Math.floor(gameTime / 60); 
        let seconds = gameTime % 60; 
        timerDisplay.textContent = `Tempo: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`; 
    }

    function triggerScreenShake() { gameWrapper.classList.add('shake'); setTimeout(() => gameWrapper.classList.remove('shake'), 350); }
    function initiateGoalSequence(scoringPlayer) {
        if (goalPauseActive) return; 
        scoringPlayer.score++; 
        lastScorer = scoringPlayer; 
        if (settings.gameMode === 'single') { 
            cpuCanMove = false; 
        }
        updateScoreDisplay(); triggerScreenShake(); 
        goalPauseActive = true; goalPauseTimer = GOAL_PAUSE_DURATION; 
        if (gameInterval) { clearInterval(gameInterval); 
            gameInterval = null; 
        }
    }

    function performDirectedKickoff(receivingPlayer) {
        ball.x = fieldWidth / 2; 
        ball.y = fieldHeight / 2; 
        ball.vx = 0; 
        ball.vy = 0; 
        let kickoffAngle = Math.random() * Math.PI / 4 - Math.PI / 8; /* Angulo aleatório de +/- 22.5 graus */ 
        const kickoffSpeed = ball.speed * 0.4; /* Um chute moderado */ 

        if (receivingPlayer === player1) { // Chuta para o jogador 1 (lado esquerdo)
            ball.vx = -Math.cos(kickoffAngle) * kickoffSpeed; 
            ball.vy = Math.sin(kickoffAngle) * kickoffSpeed; 
        } else { // Chuta para o jogador 2/CPU (lado direito)
            ball.vx = Math.cos(kickoffAngle) * kickoffSpeed; 
            ball.vy = Math.sin(kickoffAngle) * kickoffSpeed; 
        }
    }

    function finishGoalSequence() {
        goalPauseActive = false; 
        ball.x = fieldWidth / 2; ball.y = fieldHeight / 2; ball.vx = 0; ball.vy = 0; 
        player1.x = 150; 
        player1.y = fieldHeight / 2; player2.x = fieldWidth - 150; player2.y = fieldHeight / 2; 
        drawEverything(); 
        setTimeout(() => { 
            if (!isGameRunning) return; 
            const receivingPlayer = lastScorer === player1 ? player2 : player1;
            performDirectedKickoff(receivingPlayer);
            startGameTimer();
            if (settings.gameMode === 'single') { 
                 setTimeout(() => { 
                    cpuCanMove = true; 
                }, 300); 
            }
        }, KICKOFF_DELAY); 
    }

    function handleBallKick(playerObj) {
        let dx_from_player_to_ball = ball.x - playerObj.x; 
        let dy_from_player_to_ball = ball.y - playerObj.y; 
        let distance = Math.sqrt(dx_from_player_to_ball * dx_from_player_to_ball + dy_from_player_to_ball * dy_from_player_to_ball); 
        if (distance < playerRadius + ballRadius) { 
            let overlap = (playerRadius + ballRadius) - distance; 
            let angleForOverlapCorrection = Math.atan2(dy_from_player_to_ball, dx_from_player_to_ball); 
            ball.x += Math.cos(angleForOverlapCorrection) * (overlap + 0.1);  
            ball.y += Math.sin(angleForOverlapCorrection) * (overlap + 0.1); 
            let kickAngle = Math.atan2(ball.y - playerObj.y, ball.x - playerObj.x); 

            const kickStrength = 1.4; /* Unified and adjusted kick strength */ 

            ball.vx = Math.cos(kickAngle) * ball.speed * kickStrength; 
            ball.vy = Math.sin(kickAngle) * ball.speed * kickStrength; 

            let currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy); 
            if (currentSpeed > ball.maxSpeed) { 
                ball.vx = (ball.vx / currentSpeed) * ball.maxSpeed; 
                ball.vy = (ball.vy / currentSpeed) * ball.maxSpeed; 
            }
        }
    }

    function handlePlayerCollision(p1, p2) {
        let dx = p2.x - p1.x; 
        let dy = p2.y - p1.y; let distance = Math.sqrt(dx * dx + dy * dy); 
        let minDistance = playerRadius * 2; 
        if (distance < minDistance && distance > 0) { 
            let overlap = (minDistance - distance) / 2; 
            let angle = Math.atan2(dy, dx); 
            p1.x -= Math.cos(angle) * overlap; p1.y -= Math.sin(angle) * overlap; 
            p2.x += Math.cos(angle) * overlap; 
            p2.y += Math.sin(angle) * overlap; 
        }
    }

    // ##### CPU AI LOGIC - REVISED FOR COMPETITIVENESS & "PONG-LIKE" STRATEGY #####
    function updateOpponentMovement() {
        if (!cpuCanMove) return; 

        const cpu = player2;
        const now = Date.now(); 

        // --- 1. Perception: Gather information about the game state ---
        const ballDistToCpu = Math.sqrt(Math.pow(ball.x - cpu.x, 2) + Math.pow(ball.y - cpu.y, 2)); 
        const ballDistToP1 = Math.sqrt(Math.pow(ball.x - player1.x, 2) + Math.pow(ball.y - player1.y, 2)); 

        const cpuGoalX = fieldWidth - goalPostRadius; /* Center of CPU's goal line (right) */ 
        const p1GoalX = goalPostRadius; /* Center of Player 1's goal line (left) */ 
        const goalCenterY = fieldHeight / 2; 

        const ballDistToCpuGoal = Math.sqrt(Math.pow(ball.x - cpuGoalX, 2) + Math.pow(ball.y - goalCenterY, 2)); 
        const ballDistToP1Goal = Math.sqrt(Math.pow(ball.x - p1GoalX, 2) + Math.pow(ball.y - goalCenterY, 2)); 

        const cpuHasPossession = ballDistToCpu < playerRadius + ballRadius + 5 && (ballDistToCpu < ballDistToP1 - 10 || (ball.vx === 0 && ball.vy === 0 && ballDistToCpu < playerRadius + ballRadius + 15)); 
        const p1HasPossession = ballDistToP1 < playerRadius + ballRadius + 5 && ballDistToP1 < ballDistToCpu - 10; 

        let rawTargetX = cpuStrategicTargetX; 
        let rawTargetY = cpuStrategicTargetY; 

        // --- 2. Strategic Decision Making (updates periodically) ---
        if (now > cpuLastStrategicUpdateTime + AI_STRATEGIC_UPDATE_INTERVAL_MS) {
            cpuLastStrategicUpdateTime = now; 

            // Define threat levels from Player 1 and ball's state
            const isP1ShootingThreat = p1HasPossession && player1.x > fieldWidth * 0.45 && player1.x < cpu.x && Math.abs(player1.y - goalCenterY) < goalHeight * 0.85;
            const isBallFlyingToCpuGoal = !p1HasPossession && !cpuHasPossession && ball.vx > 2.5 && ball.x > fieldWidth * 0.5 && ball.x < cpuGoalX - ballRadius && Math.abs(ball.y - goalCenterY) < goalHeight * 0.9;
            const isBallLooseAndDangerous = !p1HasPossession && !cpuHasPossession && ball.x > fieldWidth * 0.60 && ballDistToCpuGoal < fieldWidth * 0.33;

            // A. CRITICAL DEFENSE (Pong-style block)
            if (isP1ShootingThreat || isBallFlyingToCpuGoal || isBallLooseAndDangerous) {
                rawTargetX = fieldWidth * 0.75; // Default defensive line X
                rawTargetY = goalCenterY;    // Default defensive line Y

                if (isBallFlyingToCpuGoal) {
                    let timeToReachDefLine = ((fieldWidth * 0.82) - ball.x) / ball.vx;
                    if (timeToReachDefLine > 0.05 && timeToReachDefLine < 1.5) { // plausible intercept time
                        rawTargetY = ball.y + ball.vy * timeToReachDefLine * 0.80; // Predict Y, slightly conservative
                        rawTargetX = fieldWidth * 0.82; // Intercept further up if possible
                    } else { // Ball too fast or unpredictable, basic block
                        rawTargetY = ball.y;
                        rawTargetX = ball.x + playerRadius * 2; // Get goal-side of ball
                    }
                } else if (isP1ShootingThreat) {
                    // Position to block Player 1's likely shot path
                    rawTargetX = player1.x + (cpuGoalX - player1.x) * 0.25; // Position between P1 and goal center
                    rawTargetY = player1.y + (ball.y - player1.y) * 0.4; // Blend of P1's Y and ball's Y
                } else { // isBallLooseAndDangerous
                    rawTargetX = ball.x + playerRadius * 1.5; // Get goal-side of the loose dangerous ball
                    rawTargetY = ball.y;
                }
                // Ensure CPU stays in its defensive half predominantly
                rawTargetX = Math.max(fieldWidth / 2 + playerRadius, rawTargetX);
                rawTargetY = Math.max(playerRadius, Math.min(fieldHeight - playerRadius, rawTargetY)); // Clamp Y to field

            }
            // B. OFFENSIVE ACTION (CPU has possession - "Pong" shoot)
            else if (cpuHasPossession) {
                let aim_y_at_p1_goal = goalCenterY;
                // Check Player 1's position to aim away if P1 is defending
                const p1_is_defending_center = player1.x < fieldWidth * 0.35 && player1.x > 0 && Math.abs(player1.y - goalCenterY) < goalHeight * 0.5;
                const p1_on_their_half = player1.x < fieldWidth / 2;

                if (p1_is_defending_center) { // P1 is blocking goal center
                    aim_y_at_p1_goal = (player1.y > goalCenterY) ?
                                     (goalCenterY - goalHeight * 0.25 - (Math.random() * goalHeight * 0.20)) :
                                     (goalCenterY + goalHeight * 0.25 + (Math.random() * goalHeight * 0.20));
                } else if (p1_on_their_half) { // P1 is on their side, but not necessarily centered
                    aim_y_at_p1_goal = goalCenterY + (Math.random() - 0.5) * goalHeight * 0.8; // Wider random aim
                } else { // P1 is far or out of position
                    aim_y_at_p1_goal = goalCenterY + (Math.random() - 0.5) * goalHeight * 0.6;
                }
                // Ensure aim is within the goal posts
                aim_y_at_p1_goal = Math.max(goalLineY1 + ballRadius + 5, Math.min(goalLineY2 - ballRadius - 5, aim_y_at_p1_goal));

                // Calculate vector from ball to aimed point in P1's goal
                let kick_target_dx = p1GoalX - ball.x;
                let kick_target_dy = aim_y_at_p1_goal - ball.y;
                let kick_target_dist = Math.sqrt(kick_target_dx * kick_target_dx + kick_target_dy * kick_target_dy);

                let kick_setup_dx = (kick_target_dist > 0) ? kick_target_dx / kick_target_dist : -1; // Normalized direction
                let kick_setup_dy = (kick_target_dist > 0) ? kick_target_dy / kick_target_dist : 0;

                let setup_distance_behind_ball = playerRadius * 0.4 + (Math.random() * playerRadius * 0.3);

                // Target position for CPU to line up the kick (behind the ball relative to kick direction)
                rawTargetX = ball.x - kick_setup_dx * setup_distance_behind_ball;
                rawTargetY = ball.y - kick_setup_dy * setup_distance_behind_ball;

                // If very close to P1's goal (e.g. scramble), just try to push it in
                if (ball.x < fieldWidth * 0.25 && ballDistToP1Goal < playerRadius * 5) {
                    rawTargetX = ball.x + playerRadius * 1.2; // Simple push from right
                    rawTargetY = ball.y + (goalCenterY - ball.y) * 0.4; // Nudge towards goal center
                }
            }
            // C. CONTEST LOOSE BALL (Neither has possession, CPU will try to get it)
            else if (!p1HasPossession && (ballDistToCpu < ballDistToP1 + playerRadius * 2.0 || ball.x > fieldWidth * 0.45) ) {
                rawTargetX = ball.x;
                rawTargetY = ball.y;
                // If ball is moving, try to intercept
                if (Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy) > 0.5 && ballDistToCpu > playerRadius * 1.5) {
                    let time_to_ball = ballDistToCpu / (opponent.speed * 0.8 + 0.1); // Estimated time to reach current ball pos
                    rawTargetX = ball.x + ball.vx * time_to_ball * 0.55; // Aim for predicted position
                    rawTargetY = ball.y + ball.vy * time_to_ball * 0.55;
                }
            }
            // D. DEFAULT/FALLBACK POSITIONING
            else {
                rawTargetX = fieldWidth * 0.72; // General defensive area on its side
                rawTargetY = goalCenterY + (ball.y - goalCenterY) * 0.55; // Align somewhat with ball's Y position
                // If ball is midfield and somewhat close, be more proactive
                if (ball.x > fieldWidth * 0.3 && ball.x < fieldWidth * 0.7 && ballDistToCpu < fieldWidth * 0.35) {
                    rawTargetX = ball.x;
                    rawTargetY = ball.y;
                }
            }

            // Clamp final strategic targets to field boundaries
            // CPU can cross midline if it has possession and is attacking, otherwise stays more defensive.
            if (!cpuHasPossession || (cpuHasPossession && rawTargetX > fieldWidth * 0.65 && ball.x < fieldWidth * 0.6)) { // Not possessing, or possessing but retreating/defensive
                 rawTargetX = Math.max(fieldWidth / 2 + playerRadius, Math.min(fieldWidth - playerRadius, rawTargetX));
            } else { // Attacking with possession, allowed to cross midline
                 rawTargetX = Math.max(playerRadius, Math.min(fieldWidth - playerRadius, rawTargetX));
            }
            rawTargetY = Math.max(playerRadius, Math.min(fieldHeight - playerRadius, rawTargetY));
            cpuStrategicTargetX = rawTargetX;
            cpuStrategicTargetY = rawTargetY;
        }

        // --- 3. Movement Execution (towards strategic target) ---
        let dxToTarget = cpuStrategicTargetX - cpu.x; 
        let dyToTarget = cpuStrategicTargetY - cpu.y; 
        let distanceToTarget = Math.sqrt(dxToTarget * dxToTarget + dyToTarget * dyToTarget); 
        let currentAppliedSpeed = opponent.speed; 

        let baseSpeedFactor = 0.98; // Slightly more responsive 
        if (distanceToTarget < playerRadius * 4) { baseSpeedFactor = 0.85; }
        if (distanceToTarget < playerRadius * 1.5) { baseSpeedFactor = 0.65; }

        let randomFluctuation = (Math.random() * 0.2) - 0.10; // Range: -10% to +10% for slight unpredictability 
        let finalSpeedFactor = baseSpeedFactor * (1 + randomFluctuation); 
        finalSpeedFactor = Math.max(0.2, Math.min(1.0, finalSpeedFactor)); // Clamp factor 

        if (distanceToTarget > playerRadius * 0.2) { // Small threshold to prevent jittering at target
            cpu.x += (dxToTarget / distanceToTarget) * currentAppliedSpeed * finalSpeedFactor; 
            cpu.y += (dyToTarget / distanceToTarget) * currentAppliedSpeed * finalSpeedFactor; 
        }
    }
    // ##### END OF REVISED CPU AI LOGIC #####


    function checkBallWallCollision() {
        const bounceFactor = -0.75; 
        if (ball.y - ballRadius < 0) { ball.y = ballRadius; 
            ball.vy *= bounceFactor; 
        }
        else if (ball.y + ballRadius > fieldHeight) { ball.y = fieldHeight - ballRadius; 
            ball.vy *= bounceFactor; } 

        if (ball.x - ballRadius < goalPostRadius && (ball.y < goalLineY1 || ball.y > goalLineY2)) { 
            ball.x = goalPostRadius + ballRadius; 
            ball.vx *= bounceFactor; 
        } else if (ball.x + ballRadius > fieldWidth - goalPostRadius && (ball.y < goalLineY1 || ball.y > goalLineY2)) { 
            ball.x = fieldWidth - goalPostRadius - ballRadius; 
            ball.vx *= bounceFactor; 
        }
    }

    function checkPlayerWallCollision(obj, isPlayer1 = false) {
        // Vertical collision (Y-axis) - common for all modes and positions
        if (obj.y - playerRadius < 0) obj.y = playerRadius;
        else if (obj.y + playerRadius > fieldHeight) obj.y = fieldHeight - playerRadius;

        const inGoalAreaY = obj.y > goalLineY1 && obj.y < goalLineY2;

        if (settings.gameMode === 'single') {
            if (isPlayer1) { // Player 1 in single player mode
                // Wall collision
                if (obj.x - playerRadius < 0) obj.x = playerRadius;
                // Half-field restriction for P1
                if (obj.x + playerRadius > fieldWidth / 2) obj.x = fieldWidth / 2 - playerRadius;
            } else { // CPU (Player 2) in single player mode
                // Wall collision
                if (obj.x + playerRadius > fieldWidth) obj.x = fieldWidth - playerRadius;
                // Half-field restriction for CPU (stays on its side)
                if (obj.x - playerRadius < fieldWidth / 2) obj.x = fieldWidth / 2 + playerRadius;
            }
        } else { // Multiplayer mode
            if (isPlayer1) { // Player 1 in multiplayer
                if (inGoalAreaY) {
                    // Collide with the back of the net (x=0)
                    if (obj.x - playerRadius < 0) obj.x = playerRadius;
                } else {
                    // Collide with the solid part of the side walls
                    if (obj.x - playerRadius < goalPostRadius) obj.x = goalPostRadius + playerRadius;
                }
                // Half-field restriction for P1
                if (obj.x + playerRadius > fieldWidth / 2) obj.x = fieldWidth / 2 - playerRadius;
            } else { // Player 2 in multiplayer
                if (inGoalAreaY) {
                    // Collide with the back of the net (x=fieldWidth)
                    if (obj.x + playerRadius > fieldWidth) obj.x = fieldWidth - playerRadius;
                } else {
                    // Collide with the solid part of the side walls
                    if (obj.x + playerRadius > fieldWidth - goalPostRadius) obj.x = fieldWidth - goalPostRadius - playerRadius;
                }
                // Half-field restriction for P2
                if (obj.x - playerRadius < fieldWidth / 2) obj.x = fieldWidth / 2 + playerRadius;
            }
        }
    }


    function checkBallPostCollision() {
        const bounceFactor = 0.75; 
        for (const post of goalPosts) { 
            const dx = ball.x - post.x; 
            const dy = ball.y - post.y; 
            const distance = Math.sqrt(dx * dx + dy * dy); 
            const combinedRadii = ballRadius + post.radius; 

            if (distance < combinedRadii) { 
                const overlap = combinedRadii - distance; 
                const angle = Math.atan2(dy, dx);  

                ball.x += Math.cos(angle) * (overlap + 0.1); 
                ball.y += Math.sin(angle) * (overlap + 0.1); 
                const normalX = dx / distance; 
                const normalY = dy / distance; 
                const dotProduct = ball.vx * normalX + ball.vy * normalY; 

                ball.vx -= 2 * dotProduct * normalX; 
                ball.vy -= 2 * dotProduct * normalY; 

                ball.vx *= bounceFactor; 
                ball.vy *= bounceFactor; 

                triggerScreenShake();  
                return true; 
            }
        }
        return false; 
    }


    function checkGoal() {
        if (goalPauseActive) return; 
        if (ball.x - ballRadius < 0 && ball.y > goalLineY1 && ball.y < goalLineY2) { initiateGoalSequence(player2); } // Goal for Player 2 (CPU/Right)
        else if (ball.x + ballRadius > fieldWidth && ball.y > goalLineY1 && ball.y < goalLineY2) { initiateGoalSequence(player1); } // Goal for Player 1 (Left)
    }

    function update() {
        // Player 1 movement
        if (settings.gameMode === 'single' && settings.controlMode === 'keyboard') {
            if (keys['KeyW'] || keys['ArrowUp']) player1.y -= player1.speed; 
            if (keys['KeyS'] || keys['ArrowDown']) player1.y += player1.speed; 
            if (keys['KeyA'] || keys['ArrowLeft']) player1.x -= player1.speed; 
            if (keys['KeyD'] || keys['ArrowRight']) player1.x += player1.speed; 
        } else if (settings.gameMode === 'multiplayer') { // Player 1 in multiplayer
            if (keys['KeyW']) player1.y -= player1.speed; 
            if (keys['KeyS']) player1.y += player1.speed; 
            if (keys['KeyA']) player1.x -= player1.speed; 
            if (keys['KeyD']) player1.x += player1.speed; 
        }
        // Note: Mouse movement for P1 in single player is handled in its event listener.

        // Player 2 movement (Human P2 in multiplayer or CPU in single player)
        if (settings.gameMode === 'multiplayer') {
            if (keys['ArrowUp']) player2.y -= player2.speed; 
            if (keys['ArrowDown']) player2.y += player2.speed; 
            if (keys['ArrowLeft']) player2.x -= player2.speed; 
            if (keys['ArrowRight']) player2.x += player2.speed; 
        } else { // Single player, Player 2 is CPU
            updateOpponentMovement();
        }

        checkPlayerWallCollision(player1, true); // Player 1 specific boundary checks
        checkPlayerWallCollision(player2, false); // Player 2 (CPU or Human P2) specific boundary checks


        ball.x += ball.vx; 
        ball.y += ball.vy; ball.vx *= ball.friction; ball.vy *= ball.friction; /* Friction applied */ 
        if (Math.abs(ball.vx) < 0.015) ball.vx = 0; 
        if (Math.abs(ball.vy) < 0.015) ball.vy = 0; 

        checkBallWallCollision(); 
        if (!checkBallPostCollision()) {  
            checkGoal(); 
        }

        handleBallKick(player1);
        // Only let CPU (player2) kick if it's single player mode.
        // In multiplayer, player2 is human controlled, so their kick is natural.
        // The original handleBallKick(player2) was unconditional.
        // This means in multiplayer, player2 object was being passed to handleBallKick.
        // This is fine as player2 object contains x,y,color,speed,score for human P2 too.
        handleBallKick(player2);

        handlePlayerCollision(player1, player2); 
    }


    function gameLoop() {
        if (isPausedForMenu) { 
            if(animationFrameId) cancelAnimationFrame(animationFrameId); 
            animationFrameId = null; return; 
        }

        if (goalPauseActive) { 
            goalPauseTimer--; 
            if(ball.x < goalWidth + ballRadius || ball.x > fieldWidth - goalWidth - ballRadius){ 
                ball.vx *= 0.88; 
                ball.vy *= 0.96;  
            }
            ball.x += ball.vx; 
            ball.y += ball.vy; 
            drawEverything(); 
            if (goalPauseTimer <= 0) { finishGoalSequence(); }
        } else if (isGameRunning) { 
            update(); 
            drawEverything(); 
        } else { 
            drawEverything(); 
        }
        animationFrameId = requestAnimationFrame(gameLoop); 
    }

    function startGameTimer() {
        if (gameInterval) clearInterval(gameInterval); 
        gameInterval = setInterval(() => { 
            if (isGameRunning && !isPausedForMenu && !goalPauseActive && gameTime > 0) { 
                gameTime--; updateTimerDisplay(); 
            } else if (gameTime <= 0 && isGameRunning) { endGame(); } 
        }, 1000); 
    }

    function startGame() {
        hideScreen(startScreen); hideScreen(endScreen); hideScreen(settingsScreen); hideScreen(customizationScreen); 
        isPausedForMenu = false; canvas.classList.remove('paused-visual'); 
        resetGameValues(); // This will also reset AI state variables
        isGameRunning = true; 
        goalPauseActive = false; 

        const randomPlayer = Math.random() < 0.5 ? player1 : player2; 
        performDirectedKickoff(randomPlayer); 

        startGameTimer(); 
        if (!animationFrameId) { animationFrameId = requestAnimationFrame(gameLoop); }
    }

    function resumeGameLogic() {
        isPausedForMenu = false; 
        canvas.classList.remove('paused-visual'); 
        if (isGameRunning && !goalPauseActive) { 
            startGameTimer(); 
            if (!animationFrameId) { animationFrameId = requestAnimationFrame(gameLoop); } 
        }
    }

    function endGame() {
        isGameRunning = false; 
        if (gameInterval) { clearInterval(gameInterval); gameInterval = null; } 
        let resultText; 
        if (player1.score > player2.score) resultText = settings.gameMode === 'single' ? "Você Venceu!" : "Jogador 1 Venceu!"; 
        else if (player1.score < player2.score) resultText = settings.gameMode === 'single' ? "Você Perdeu!" : "Jogador 2 Venceu!"; 
        else resultText = "Empate!"; 
        endTitle.textContent = resultText; 
        finalScoreDisplay.textContent = `Placar final: ${player1.score} - ${player2.score}`; 
        showScreen(endScreen); 
    }

    function resetGameValues() {
        player1.score = 0; player2.score = 0; 
        player1.x = 150; player1.y = fieldHeight / 2; 
        player2.x = fieldWidth - 150; player2.y = fieldHeight / 2; 
        ball.x = fieldWidth / 2; ball.y = fieldHeight / 2; ball.vx = 0; ball.vy = 0; 
        gameTime = 120; 
        updateScoreDisplay(); 
        updateTimerDisplay(); 
        goalPauseActive = false; goalPauseTimer = 0; lastScorer = null; 
        // Reset AI state variables
        cpuCanMove = true; 
        cpuStrategicTargetX = fieldWidth - 150; 
        cpuStrategicTargetY = fieldHeight / 2; 
        cpuLastStrategicUpdateTime = 0;  
    }

    window.addEventListener('keydown', (e) => { keys[e.code] = true; }); 
    window.addEventListener('keyup', (e) => { keys[e.code] = false; }); 
    canvas.addEventListener('mousemove', (e) => { 
        if (settings.gameMode === 'single' && settings.controlMode === 'mouse' && isGameRunning && !isPausedForMenu && !goalPauseActive) { 
            let rect = canvas.getBoundingClientRect(); let scaleX = canvas.width / rect.width; let scaleY = canvas.height / rect.height; 
            let mouseX = (e.clientX - rect.left) * scaleX; let mouseY = (e.clientY - rect.top) * scaleY; 

            const targetX = Math.min(mouseX, fieldWidth / 2 - playerRadius); 
            player1.x += (targetX - player1.x) * 0.45;  
            player1.y += (mouseY - player1.y) * 0.45; 
             checkPlayerWallCollision(player1, true);  
        }
    });
    ['touchmove', 'touchstart'].forEach(evt => canvas.addEventListener(evt, (e) => { 
        if (settings.gameMode === 'single' && settings.controlMode === 'mouse') { 
            e.preventDefault(); 
            if (isGameRunning && !isPausedForMenu && !goalPauseActive && e.touches[0]) { 
                let rect = canvas.getBoundingClientRect(); let scaleX = canvas.width / rect.width; let scaleY = canvas.height / rect.height; 
                let touchX = (e.touches[0].clientX - rect.left) * scaleX;  
                let touchY = (e.touches[0].clientY - rect.top) * scaleY; 
                const targetX = Math.min(touchX, fieldWidth / 2 - playerRadius);  
                player1.x += (targetX - player1.x) * 0.45; 
                player1.y += (touchY - player1.y) * 0.45; 
                checkPlayerWallCollision(player1, true); 
            }
        }
    }, { passive: false })); 

    startButton.addEventListener('click', startGame); 
    playAgainButton.addEventListener('click', startGame); 
    settingsButton.addEventListener('click', openSettingsMenu); 
    openSettingsButton.addEventListener('click', openSettingsMenu); 
    closeSettingsButton.addEventListener('click', closeSettingsMenu); 
    customizeButton.addEventListener('click', () => { hideScreen(settingsScreen); showScreen(customizationScreen); }); 
    backButton.addEventListener('click', () => { hideScreen(customizationScreen); showScreen(settingsScreen); }); 
    singlePlayerButton.addEventListener('click', () => { settings.gameMode = 'single'; updateSettingsUI(); saveSettings(); }); 
    multiPlayerButton.addEventListener('click', () => { settings.gameMode = 'multiplayer'; updateSettingsUI(); saveSettings(); }); 
    keyboardButton.addEventListener('click', () => { settings.controlMode = 'keyboard'; updateSettingsUI(); saveSettings(); }); 
    mouseButton.addEventListener('click', () => { settings.controlMode = 'mouse'; updateSettingsUI(); saveSettings(); }); 

    loadSettings(); 
    createColorPicker(player1ColorPicker, 'player1Color'); 
    createColorPicker(player2ColorPicker, 'player2Color'); 
    updateSettingsUI(); 

    updateTimerDisplay(); 
    drawEverything();  
    showScreen(startScreen);

</script>
</body>
</html>